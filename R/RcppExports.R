# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'@useDynLib LS3MU
#'@import Rcpp
#'@import RcppEigen
Laplacian_path <- function(Z, y, tauList, spike_params, slab_param, beta_init, sigma_update, sigma_init, theta_init, a, b, omega, kappa, tolerance, max_iter, return_g) {
    .Call('_LS3MU_Laplacian_path', PACKAGE = 'LS3MU', Z, y, tauList, spike_params, slab_param, beta_init, sigma_update, sigma_init, theta_init, a, b, omega, kappa, tolerance, max_iter, return_g)
}

#'@title posteriorX
#'
#'@description
#'In ordinary regression model, assuming each column of the design matrix \code{Z} contains additive
#'Gaussian measurement errors with known variance collected in \code{tauList}, function 'posteriorX'
#'returns posterior expectation as well as some related values for the true design matrix \eqn{X}.
#'
#'More specifically, if we denote the measurement error matrix as \eqn{\Xi},
#'then the measurement error model takes the form: \eqn{Z = X + \Xi}.
#'Since we have \eqn{y_i|\bold{x_i},\bold{\beta},\sigma^2 \sim N(\bold{x_i^\top }\bold{\beta},\sigma^2)}
#'and \eqn{\bold{x_i}|\bold{z_i}, \Lambda \sim N(\bold{z_i}, \Lambda)}
#'where \eqn{\Lambda} is the diagonal matrix consists of \code{tauList},
#'\code{posteriorX} computes the expectation of \eqn{X}, variance of \eqn{\bold{x_i}} and
#'expectation of \eqn{X^\top X} conditioning on \eqn{\bold{\beta}}, \eqn{\bold{y}}, \eqn{Z},
#'\eqn{\Lambda} and \eqn{\sigma}.
#'
#'This is part of E-step in the 'lsum' function.
#'
#'
#'
#'@param Z \eqn{n * p} covariate matrix with additive errors
#'in each column (possibly \eqn{p>n}). It is assumed the
#'measurement error model takes the form \eqn{Z = X + \Xi},
#'where \eqn{X} is the unknown true design matrix and
#'\eqn{\Xi} is the matrix of i.i.d Gaussian measurement errors of mean \eqn{0}
#'and same variance within each column.
#'
#'@param y Numeric response vector from \eqn{n} observations.
#'
#'@param beta Regression parameter vector of length \eqn{p}.
#'
#'@param sigma Numeric. The standard deviance of regression model error terms.
#'
#'@param tauList Vector of length \eqn{p}. Corresponding variances of additive
#'measurement error for p columns.
#'
#'
#'@returns
#''posteriorX' returns a list containing the following values:
#'
#'\item{hatX}{\eqn{n * p} matrix. The expectation of \eqn{X} conditional on
#'\eqn{\bold{\beta}}, \eqn{\bold{y}}, \eqn{Z}, \eqn{\Lambda} and \eqn{\sigma}.}
#'
#'\item{hatSigma}{\eqn{p * p} matrix. The variance of \eqn{\bold{x_i}} conditional on
#'\eqn{\bold{\beta}}, \eqn{\bold{y}}, \eqn{Z}, \eqn{\Lambda} and \eqn{\sigma},
#'which is equivalent for each \eqn{\bold{x_i}}.}
#'
#'\item{hatXX}{\eqn{p * p} matrix. The conditional expectation of \eqn{X^\top X}.
#'\code{hatXX = t(hatX) * hatX + hatSigma}.}
#'
#'@examples
#'require(MASS)
#'n = 200
#'p = 500
#'
#'set.seed(1234)
#'beta_true = c(-3, 2, -1.5, -2, 3, rep(0,p-5))
#'X = matrix(rnorm(n*p, 0, 1), nrow = n)
#'epsilon = rnorm(n, 0, 1)
#'y = X %*% beta_true+epsilon
#'
#'tau = sample(seq(0.5,0.9,by = 0.1), size = p, replace = TRUE)
#'Xi = mvrnorm(n, rep(0,p), diag(tau))
#'Z = X + Xi
#'
#'post_X = posteriorX(Z, y, beta = beta_true, sigma = 1, tauList = tau)
#'
#'
#'@useDynLib LS3MU
#'@import Rcpp
#'@import RcppEigen
#'@export
posteriorX <- function(Z, y, beta, sigma, tauList) {
    .Call('_LS3MU_posteriorX', PACKAGE = 'LS3MU', Z, y, beta, sigma, tauList)
}

#'@useDynLib LS3MU
#'@import Rcpp
#'@import RcppEigen
#'@export
comp_g <- function(Laplacian, y, Z, tauList, hatSigma, hatX, hatXX, p_k, spike_param, slab_param, omega, kappa, a, b, sigma, theta, beta) {
    .Call('_LS3MU_comp_g', PACKAGE = 'LS3MU', Laplacian, y, Z, tauList, hatSigma, hatX, hatXX, p_k, spike_param, slab_param, omega, kappa, a, b, sigma, theta, beta)
}

